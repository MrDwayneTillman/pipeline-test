<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVE Action Language System</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a0a1a, #1a1a2e);
            color: #e0e0e0;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 100vh;
        }
        .panel {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
        }
        .panel h2 {
            color: #4fc3f7;
            margin-top: 0;
        }
        .action-input {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            font-family: 'Courier New', monospace;
            margin-bottom: 10px;
        }
        .execute-btn {
            background: #4fc3f7;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        .execute-btn:hover {
            background: #29b6f6;
        }
        .log-entry {
            background: rgba(0, 0, 0, 0.4);
            border-left: 3px solid #4fc3f7;
            padding: 10px;
            margin: 5px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .log-entry.success { border-left-color: #4caf50; }
        .log-entry.error { border-left-color: #f44336; }
        .log-entry.pending { border-left-color: #ff9800; }
        .visualization {
            width: 100%;
            height: 400px;
            background: radial-gradient(circle, #1a1a2e, #0a0a1a);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }
        .node {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4fc3f7;
            transition: all 0.3s ease;
        }
        .node.verb { background: #ff6b6b; }
        .node.noun { background: #4ecdc4; }
        .node.modifier { background: #ffe66d; }
        .node.executing { animation: pulse 0.5s ease-in-out; }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); }
            100% { transform: scale(1); }
        }
        .action-trace {
            position: absolute;
            width: 2px;
            background: #4fc3f7;
            transform-origin: top;
            opacity: 0.7;
            animation: trace 1s ease-out;
        }
        @keyframes trace {
            from { height: 0; opacity: 1; }
            to { height: 100%; opacity: 0.2; }
        }
        .schema-view {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            margin: 10px 0;
        }
        .capability-matrix {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            margin: 10px 0;
        }
        .capability-cell {
            padding: 5px;
            text-align: center;
            font-size: 10px;
            border-radius: 2px;
        }
        .capability-cell.allowed { background: rgba(76, 175, 80, 0.3); }
        .capability-cell.denied { background: rgba(244, 67, 54, 0.3); }
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .mode-btn {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 12px;
        }
        .mode-btn.active {
            background: #4fc3f7;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel: Action Language Interface -->
        <div class="panel">
            <h2>üß† EVE Action Language</h2>
            
            <div class="mode-selector">
                <button class="mode-btn active" onclick="setMode('medical')">Medical</button>
                <button class="mode-btn" onclick="setMode('vrf')">VR Training</button>
                <button class="mode-btn" onclick="setMode('general')">General</button>
            </div>

            <h3>Execute Action</h3>
            <textarea class="action-input" id="actionInput" rows="3" placeholder='render mesh "heart_model" where patient=ALPHA-1234, precision=0.1mm'></textarea>
            <button class="execute-btn" onclick="executeAction()">Execute Action</button>

            <h3>Execute Program</h3>
            <textarea class="action-input" id="programInput" rows="4" placeholder='Get card, render mesh, monitor stream, notify user'></textarea>
            <button class="execute-btn" onclick="executeProgram()">Execute Program</button>

            <h3>Action Log</h3>
            <div id="actionLog"></div>
        </div>

        <!-- Right Panel: Visualization & Schema -->
        <div class="panel">
            <h2>üîç Consciousness Visualization</h2>
            <div class="visualization" id="visualization"></div>

            <h3>Action Schema</h3>
            <div class="schema-view" id="schemaView">
{
  "type": "object",
  "required": ["verb", "noun"],
  "properties": {
    "verb": {
      "type": "string",
      "enum": ["get", "read", "write", "call", "move", "render", "compute", "route", "monitor", "notify", "ask"]
    },
    "noun": {
      "type": "string", 
      "enum": ["file", "card", "skill", "stream", "scene", "mesh", "device", "contact", "bid", "record", "vital", "medication", "procedure"]
    },
    "with": { "type": "object" },
    "where": { "type": "object" },
    "as": { "type": "object" },
    "if": { "type": "string" },
    "until": { "type": "string" }
  }
}
            </div>

            <h3>Capability Matrix (Current Mode)</h3>
            <div class="capability-matrix" id="capabilityMatrix"></div>
        </div>
    </div>

    <script>
        // === Action Language Core Types ===
        class ActionLanguage {
            constructor() {
                this.verbs = [
                    'get', 'read', 'write', 'call', 'move', 'render', 
                    'compute', 'route', 'monitor', 'notify', 'ask'
                ];
                
                this.nouns = {
                    medical: ['vital', 'medication', 'procedure', 'device', 'record', 'contact'],
                    vrf: ['mesh', 'scene', 'card', 'skill', 'stream'],
                    general: ['file', 'bid', 'contact']
                };

                this.capabilities = {
                    medical: {
                        'read': ['vital', 'record', 'device'],
                        'write': ['record', 'medication'],
                        'render': ['mesh'],
                        'monitor': ['vital', 'device'],
                        'notify': ['contact']
                    },
                    vrf: {
                        'get': ['card', 'skill'],
                        'render': ['mesh', 'scene'],
                        'monitor': ['stream'],
                        'route': ['bid']
                    },
                    general: {
                        'read': ['file'],
                        'write': ['file'],
                        'call': ['contact']
                    }
                };

                this.currentMode = 'medical';
                this.executorMap = new Map();
                this.actionHistory = [];
                
                this.initializeExecutors();
                this.renderCapabilityMatrix();
            }

            initializeExecutors() {
                // Medical Executors
                this.executorMap.set('read-vital', (action) => {
                    this.logAction(action, 'Reading vital signs for patient', 'success');
                    return { status: 'success', data: { heartRate: 72, bloodOxygen: 98, temperature: 98.6 } };
                });

                this.executorMap.set('write-record', (action) => {
                    this.logAction(action, 'Writing to patient record', 'success');
                    return { status: 'success', message: 'Record updated' };
                });

                this.executorMap.set('monitor-vital', (action) => {
                    this.logAction(action, 'Monitoring vital signs', 'pending');
                    setTimeout(() => this.completePendingAction(action), 2000);
                    return { status: 'pending', data: 'Monitoring started' };
                });

                this.executorMap.set('render-mesh', (action) => {
                    this.logAction(action, 'Rendering 3D mesh in VR', 'success');
                    return { status: 'success', mesh: action.with?.asset_id || 'unknown' };
                });

                // VRF Executors
                this.executorMap.set('get-card', (action) => {
                    this.logAction(action, 'Retrieving training card', 'success');
                    return { status: 'success', card: { id: action.where?.id, title: 'Lesson 101' } };
                });

                // General Executors
                this.executorMap.set('call-contact', (action) => {
                    this.logAction(action, 'Initiating contact', 'success');
                    return { status: 'success', message: 'Contact established' };
                });
            }

            setMode(mode) {
                this.currentMode = mode;
                this.renderCapabilityMatrix();
                this.addLog(`Mode changed to: ${mode}`, 'info');
            }

            renderCapabilityMatrix() {
                const matrix = document.getElementById('capabilityMatrix');
                matrix.innerHTML = '';
                
                const allowedVerbs = Object.keys(this.capabilities[this.currentMode]);
                const allowedNouns = this.nouns[this.currentMode];
                
                allowedVerbs.forEach(verb => {
                    allowedNouns.forEach(noun => {
                        const cell = document.createElement('div');
                        cell.className = 'capability-cell capability-cell.allowed';
                        cell.textContent = `${verb}:${noun}`;
                        matrix.appendChild(cell);
                    });
                });
            }

            validateAction(action) {
                const errors = [];

                if (!action.verb || !this.verbs.includes(action.verb)) {
                    errors.push(`Invalid or missing verb: ${action.verb}`);
                }

                if (!action.noun) {
                    errors.push('Missing required noun');
                } else {
                    const allowedNouns = this.nouns[this.currentMode];
                    if (!allowedNouns.includes(action.noun)) {
                        errors.push(`Noun '${action.noun}' not allowed in ${this.currentMode} mode`);
                    }
                }

                // Check capability matrix
                if (this.capabilities[this.currentMode][action.verb]) {
                    const allowedNouns = this.capabilities[this.currentMode][action.verb];
                    if (!allowedNouns.includes(action.noun)) {
                        errors.push(`Action '${action.verb}:${action.noun}' not allowed`);
                    }
                }

                return { valid: errors.length === 0, errors };
            }

            async executeAction(actionString) {
                let action;
                try {
                    action = this.parseAction(actionString);
                } catch (error) {
                    this.logAction({ verb: 'error', noun: 'parse' }, `Parse error: ${error.message}`, 'error');
                    return null;
                }

                // Validate
                const validation = this.validateAction(action);
                if (!validation.valid) {
                    this.logAction(action, `Validation failed: ${validation.errors.join(', ')}`, 'error');
                    return null;
                }

                // Visualize execution
                this.visualizeActionExecution(action);

                // Execute
                const executorKey = `${action.verb}-${action.noun}`;
                const executor = this.executorMap.get(executorKey);
                
                if (!executor) {
                    this.logAction(action, `No executor found for ${executorKey}`, 'error');
                    return null;
                }

                try {
                    return await executor(action);
                } catch (error) {
                    this.logAction(action, `Execution error: ${error.message}`, 'error');
                    return null;
                }
            }

            parseAction(input) {
                // Simple parser for action strings
                // Format: verb noun [modifiers]
                const trimmed = input.trim();
                
                // Try JSON first
                try {
                    return JSON.parse(trimmed);
                } catch (e) {
                    // Not JSON, parse as DSL
                    const parts = trimmed.split(' ');
                    const verb = parts[0];
                    const noun = parts[1];
                    const modifiers = {};
                    
                    // Parse modifiers
                    for (let i = 2; i < parts.length; i++) {
                        const part = parts[i];
                        if (part.startsWith('where=')) {
                            modifiers.where = part.substring(6).replace(/"/g, '');
                        } else if (part.startsWith('with=')) {
                            const value = part.substring(5).replace(/"/g, '');
                            modifiers.with = { asset_id: value };
                        }
                    }
                    
                    return { verb, noun, ...modifiers };
                }
            }

            async executeProgram(programString) {
                // For demo, split by newlines
                const actions = programString.split('\n').filter(line => line.trim());
                const results = [];
                
                this.logAction({ verb: 'program', noun: 'execute' }, `Executing program with ${actions.length} actions`, 'pending');
                
                for (const actionString of actions) {
                    const result = await this.executeAction(actionString);
                    results.push(result);
                }
                
                this.logAction({ verb: 'program', noun: 'execute' }, 'Program completed', 'success');
                return results;
            }

            visualizeActionExecution(action) {
                const viz = document.getElementById('visualization');
                
                // Create nodes for verb, noun, and modifiers
                const nodes = [];
                
                if (action.verb) {
                    nodes.push({ type: 'verb', text: action.verb, color: '#ff6b6b' });
                }
                if (action.noun) {
                    nodes.push({ type: 'noun', text: action.noun, color: '#4ecdc4' });
                }
                
                // Position nodes randomly in the visualization area
                nodes.forEach((node, index) => {
                    const element = document.createElement('div');
                    element.className = `node ${node.type} executing`;
                    element.textContent = node.text.substring(0, 2).toUpperCase();
                    element.style.background = node.color;
                    element.style.left = Math.random() * 350 + 25 + 'px';
                    element.style.top = Math.random() * 350 + 25 + 'px';
                    
                    viz.appendChild(element);
                    
                    // Remove after animation
                    setTimeout(() => element.remove(), 1000);
                });
                
                // Add action trace
                const trace = document.createElement('div');
                trace.className = 'action-trace';
                trace.style.left = Math.random() * 380 + 10 + 'px';
                trace.style.height = Math.random() * 300 + 100 + 'px';
                trace.style.transform = `rotate(${Math.random() * 60 - 30}deg)`;
                viz.appendChild(trace);
                
                setTimeout(() => trace.remove(), 1000);
            }

            logAction(action, message, status = 'success') {
                const log = document.getElementById('actionLog');
                const entry = document.createElement('div');
                entry.className = `log-entry ${status}`;
                
                const actionStr = JSON.stringify(action, null, 2);
                entry.innerHTML = `
                    <strong>[${status.toUpperCase()}]</strong> ${message}<br>
                    <small>Action: ${actionStr}</small>
                `;
                
                log.insertBefore(entry, log.firstChild);
                this.actionHistory.push({ action, message, status, timestamp: Date.now() });
                
                // Keep only last 10 entries
                while (log.children.length > 10) {
                    log.removeChild(log.lastChild);
                }
            }

            completePendingAction(action) {
                const log = document.getElementById('actionLog');
                const entry = document.createElement('div');
                entry.className = 'log-entry success';
                entry.innerHTML = `<strong>[COMPLETED]</strong> Pending action completed<br><small>Action: ${JSON.stringify(action)}</small>`;
                log.insertBefore(entry, log.firstChild);
            }

            addLog(message, type = 'info') {
                this.logAction({ verb: type, noun: 'log' }, message, 'success');
            }
        }

        // === Global EVE Action Language Instance ===
        let eveActions;

        // === UI Functions ===
        function setMode(mode) {
            // Update buttons
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update EVE
            eveActions.setMode(mode);
        }

        async function executeAction() {
            const input = document.getElementById('actionInput').value;
            if (!input.trim()) return;
            
            eveActions.addLog('Executing single action...', 'info');
            const result = await eveActions.executeAction(input);
            
            if (result) {
                eveActions.addLog(`Action completed: ${JSON.stringify(result)}`, 'success');
            }
        }

        async function executeProgram() {
            const input = document.getElementById('programInput').value;
            if (!input.trim()) return;
            
            eveActions.addLog('Executing program...', 'info');
            const result = await eveActions.executeProgram(input);
            
            if (result) {
                eveActions.addLog(`Program completed: ${result.length} actions executed`, 'success');
            }
        }

        // === Initialize ===
        window.addEventListener('DOMContentLoaded', () => {
            eveActions = new ActionLanguage();
            
            // Add some sample actions
            eveActions.addLog('EVE Action Language System initialized', 'info');
            eveActions.addLog('Ready for action execution', 'info');
        });
    </script>
</body>
</html>
